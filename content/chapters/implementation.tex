This chapter outlines the implementation of the Space-Time Discontinuous Galërkin Method as presented in \Cref{chapter:cdr}. It is intended as a review of the implementation rather than a comprehensive guide detailing each component.

\section{Implementation Overview}

The algorithm has been implemented as part of a comprehensive library, \href{https://github.com/diantonioandrea/ivo}{ivo}, named after \href{https://en.wikipedia.org/wiki/Ivo_Babuška}{Ivo Babuška}, and written entirely in \lstinline{C++23} from scratch for this thesis.

The library has been designed to include all the necessary components for the implementation, use, and testing of the algorithm. These components comprise geometric methods and objects in $\RealNumbersTo{2}$ and $\RealNumbersTo{3}$ for mesh generation, dense and sparse matrices for problem formulation, and linear solvers for its solution, as well as additional linear algebra routines and utilities for the definition and manipulation of the principal equation driving the algorithm.

Moreover, the implementation of the algorithm differs slightly from the version introduced and analyzed in \Cref{chapter:cdr}.

\newpage
\section{Prismatic Meshes Over Polygonal Domains} \label{section:mesh}

Although it is not necessary to explicitly construct the full space-time mesh for this problem, doing so simplifies the process by providing a straightforward method for accessing individual elements based on their spatial index and time level. 

\subsection{Construction of Polygonal Meshes} \label{subsection:pol_mesh}

% \begin{figure}[!ht]
%     \begin{subfigure}[b]{0.49\textwidth}
% 		\centering
%         \input{content/tikz/Square_250.tex}
%     \end{subfigure}
% 	\hfill
%     \begin{subfigure}[b]{0.49\textwidth}
% 		\centering
%         \input{content/tikz/Square_2000.tex}
%     \end{subfigure}
%     \caption{Examples of polygonal meshes with $\nSpaceIndices = 250, 2000$.}
% \end{figure}

The construction of the polygonal meshes over the problem's polygonal domain is based on the Voronoi mesh construction process and Lloyd's relaxation method.

Let $\Omega \subset \RealNumbersTo{2}$ be a polygonal (and hence bounded) domain, and let $\nSpaceIndices \in \NaturalNumbers$ denote the desired number of elements for $\SpaceMesh$, i.e., the mesh to be constructed. As before, it is customary to let $h$ denote both the mesh index and its characteristic parameter.

The function used to generate polygonal meshes is \lstinline{mesher2}, defined as follows:

\begin{lstlisting}[style=cpp]
std::vector<Polygon21> mesher2(
    const Polygon21 &, 
    const Natural &)
\end{lstlisting}

This method first randomly generates $\nSpaceIndices$ points in $\Omega$ and computes their Voronoi cells by iteratively subdividing $\Omega$ using the bisectors corresponding to each point.

The initial diagram, consisting of $\nSpaceIndices$ cells, is then iteratively relaxed using Lloyd's process. At each iteration, a new diagram is generated by considering the centroids of the current cells as the generating points for the Voronoi diagram. This process continues until the residual, defined as the sum of the distances between each point and its previous position, falls below a fixed tolerance.

Finally, postprocessing is performed by collapsing edges that are too short, as such edges may introduce errors in the solution of the problem.

\newpage
\subsubsection{Mesher Details}

The following methods constitute the implementation of \lstinline{mesher2}:

\begin{lstlisting}[style=cpp]
Polygon21 reduce2(
    const Polygon21 &, 
    const Line21 &, 
    const Point21 &)

std::vector<Point21> random2(
    const Polygon21 &, 
    const Natural &)

std::vector<Polygon21> voronoi2(
    const Polygon21 &, 
    const std::vector<Point21> &)

std::vector<Polygon21> voronoi2(
    const Polygon21 &, 
    const Natural &)

void lloyd2(
    const Polygon21 &, 
    std::vector<Polygon21> &)

void collapse2(
    const Polygon21 &, 
    std::vector<Polygon21> &)
\end{lstlisting}

\lstinline{random2} is responsible for generating randomly placed points within a polygon.

\lstinline{reduce2} partitions a polygon into two parts using a line, retaining the portion in which a specified point lies.

\lstinline{voronoi2} constructs a Voronoi diagram either from a given set of points within a polygon or by first generating these points using \lstinline{random2}. It then iteratively invokes \lstinline{reduce2} to produce the complete diagram.

Finally, \lstinline{lloyd2} relaxes the diagram by iteratively invoking \lstinline{voronoi2} and adjusting the points according to Lloyd's algorithm, while \lstinline{collapse2} identifies edges that should be collapsed, removes them, and repositions any resulting disconnected polygons.

\newpage
Moreover, two additional definitions of \lstinline{mesher2} are provided to respectively load and dump polygonal meshes to a file, thereby avoiding the need to construct a new mesh at each execution:
\begin{lstlisting}[style=cpp]
std::vector<Polygon21> mesher2(
    const std::string &);

void mesher2(
    const std::string &, 
    const std::vector<Polygon21> &)
\end{lstlisting}

\subsubsection{A Code Snippet}

The following snippet illustrates the polygonal mesh construction process.

\lstinputlisting[style=cpp]{content/snippets/mesh2.cpp}

\newpage
\subsection{Construction of Prismatic Meshes}

Let $I \subset \RealNumbers$ be an open interval, and let $\SpaceMesh$ be a polygonal mesh over $\Omega \subset \RealNumbersTo{2}$, constructed as described in \cref{subsection:pol_mesh}. Let $\nTimeIndices \in \NaturalNumbers$ denote the cardinality of the partition $\TimeMesh$.

The function used to generate uniform partitions is \lstinline{mesher1}, defined as follows:
\begin{lstlisting}[style=cpp]
std::vector<Real> mesher1(
    const Real &, 
    const Real &, 
    const Natural &)
\end{lstlisting}

This method generates $\nTimeIndices + 1$ uniformly spaced points in $I$, defining its partition $\TimeMesh$.

The function used to generate prismatic meshes, formally $\TimeMesh \times \SpaceMesh$, is the constructor of \lstinline{Mesh21}, defined as follows:
\begin{lstlisting}[style=cpp]
Mesh21(
    const std::vector<Polygon21> &, 
    const std::vector<Real> &, 
    const Natural &p = 1, 
    const Natural &q = 1)
\end{lstlisting}

This method, by invoking the constructors of \lstinline{Element21} and \lstinline{Neighbour21}:
\begin{lstlisting}[style=cpp]
Element21(
    const Polygon21 &, 
    const Real &, 
    const Natural &, 
    const Natural &)

Neighbour21(
    const Integer &, 
    const Integer &, 
    const std::vector<std::array<Integer, 2>> &)
\end{lstlisting}
and relying solely on geometric information, constructs the mesh elements and the neighboring structure, where the former serve as wrappers for the element properties, and the latter is a collection of indices mapping each element to its neighbors.

\newpage
\section{Convection-Diffusion-Reaction Problems}

With meshes construced as in \Cref{section:mesh}, it is possible to construct and solve convection-diffusion-reaction problems on them.

\subsection{Polynomial Basis}

The polynomial basis chosen for both space and time consists of Legendre polynomials. This choice is motivated by the ease of generating them at runtime for a given basis degree, even when the degree varies element-wise.

The function used to generate one-dimensional Legendre polynomials is \lstinline{legendre}, defined as follows:
\begin{lstlisting}[style=cpp]
Vector<Real> legendre(
    const Vector<Real> &, 
    const Natural &, 
    const Natural &k = 0)
\end{lstlisting}

This method returns the evaluation of the $k$-th derivative of a Legendre polynomial of order $n$ using the following formula:
\begin{align}
    \frac{d^k}{dx^k} \Legendre_n(\xi) &= \frac{1}{2^k} \sum_{j = k}^{n} \binom{n}{j} \binom{n + j}{j} \left( \frac{\xi - 1}{2} \right)^{j - k} &\text{ for } \xi \in \left[ -1, 1 \right].
\end{align}

Separate basis functions for space and time can be constructed using the following functions:
\begin{lstlisting}[style=cpp]
std::array<Matrix<Real>, 2> basis_t(
    const Mesh21 &, 
    const Natural &, 
    const Vector<Real> &)

std::array<Matrix<Real>, 3> basis_xy(
    const Mesh21 &, 
    const Natural &, 
    const std::array<Vector<Real>, 2> &)
\end{lstlisting}

\lstinline{basis_t} returns the evaluations of the one-dimensional Legendre polynomials at the reference time nodes, including the appropriate scaling due to the change of variable, determined by the interval mapping.

\lstinline{basis_xy} returns the evaluations of the two-dimensional Legendre polynomials at the reference spatial nodes, incorporating the correct scaling due to the change of variable, determined by the roto-translation of the bounding box.

\newpage
\subsection{Quadrature Method} \label{subsection:quadrature}

The quadrature method of choice is the \acrfull{gl} quadrature, which, at a fixed order $n$, provides exact results for polynomials of order up to $2n - 1$.

The function used to generate \acrshort{gl} quadrature nodes and weights over a given interval is \lstinline{gauss1}, defined as follows:
\begin{lstlisting}[style=cpp]
std::array<Vector<Real>, 2> gauss1(
    const Natural &, 
    const Real &, 
    const Real &);
\end{lstlisting}
which is actually used wrapped in the following methods:
\begin{lstlisting}[style=cpp]
std::array<Vector<Real>, 2> quadrature1t(
    const Natural &)

std::array<Vector<Real>, 2> quadrature1x(
    const Natural &)

std::array<Vector<Real>, 3> quadrature2xy(
    const Natural &)
\end{lstlisting}

\lstinline{quadrature1t} returns the \acrshort{gl} quadrature nodes and weights over the reference time interval $\left[ -1, 1 \right]$, used for all time integrals.

\lstinline{quadrature1x} returns the \acrshort{gl} quadrature nodes and weights over the reference spatial interval $\left[ 0, 1 \right]$, used for all interface space integrals, i.e., integrals over element edges.

\lstinline{quadrature2xy} returns the \acrshort{gl} quadrature nodes and weights over the reference triangle with vertices $\left\{ \left( 0, 0 \right), \left( 1, 0 \right), \left( 0, 1 \right) \right\}$, used for all volume space integrals, i.e., integrals over elements.

Even though the mesh consists of polygons, quadrature is performed over subtriangulations of the elements for simplicity.

\newpage
\subsection{Equation and Data}

The equation, or the collection of the convection-diffusion-reaction parameters, and the initial and boundary data are all grouped in separate instances, built by the constructors of \lstinline{Equation}, \lstinline{Initial}, and \lstinline{Data}, defined as follows:
\begin{lstlisting}[style=cpp]
Equation(
    const 
        std::function<std::array<Real, 2> (Real, Real, Real)> &, 
    const Real &, 
    const std::function<Real (Real, Real, Real)> &)

Initial(
    const std::function<Real (Real, Real)> &)

Data(
    const std::function<Real (Real, Real, Real)> &, 
    const std::function<Real (Real, Real, Real)> &, 
    const std::function<Real (Real, Real, Real)> &)
\end{lstlisting}

\lstinline{Equation} stores information about the convection, diffusion, and reaction coefficients.

\lstinline{Initial} stores information about the initial conditions.

\lstinline{Data} stores information about the Dirichlet and Neumann boundary conditions, along with the right-hand side of the equation.

Categorizing the problem's parameters into different objects allows for solving different problems by modifying only the necessary parts.

\newpage
\subsection{Problem Construction}

The construction of the stiffness matrix and of the forcing vector, who make up for the linear system associated with the convection-diffusion-reaction problem, makes up for the main part of the construction of a convection-diffusion-reaction problem.

The functions that construct the stiffness matrix and the forcing vector are, respectively, \lstinline{stiffness} and \lstinline{forcing}, defined as follows:
\begin{lstlisting}[style=cpp]
Sparse<Real> stiffness(
    const Mesh21 &mesh, 
    const Equation &equation)

Vector<Real> forcing(
    const Mesh21 &mesh, 
    const Equation &equation, 
    const Data &data)
\end{lstlisting}
These methods operate by iterating over all elements of a mesh and performing the quadratures defined in \Cref{sec:full_discretization}.

The evaluation points for the quadratures and basis construction are obtained through the following method, which is overloaded for time intervals, space intervals, and space triangles:
\begin{lstlisting}[style=cpp]
std::tuple<Vector<Real>, Real> reference_to_element(
    const Mesh21 &, 
    const Natural &, 
    const Vector<Real> &)

std::tuple<std::array<Vector<Real>, 2>, Real> 
    reference_to_element(
        const Mesh21 &, 
        const Natural &, 
        const Natural &, 
        const std::array<Vector<Real>, 2> &)

std::tuple<std::array<Vector<Real>, 2>, Vector<Real>, Real> 
    reference_to_element(
        const Mesh21 &, 
        const Natural &, 
        const Natural &, 
        const Vector<Real> &)
\end{lstlisting}
This method, given a reference to a specific geometry, maps the reference points to the corresponding domain, preparing them for basis evaluation and quadrature scaling.

\newpage
\subsection{Problem Solution}

The function that solves the linear system associated to the convection-diffusion-reaction problem is \lstinline{solve}, defined as follows:
\begin{lstlisting}[style=cpp]
Vector<Real> solve(
    const Mesh21 &, 
    const Sparse<Real> &, 
    const Vector<Real> &, 
    const Initial &)
\end{lstlisting}

This method solves a linear system at each time level of the problem by imposing the initial conditions as those of the problem for the first level, or as the final conditions of the previous level otherwise. It then uses an iterative solver, such as \lstinline{gmres}, defined below, to solve the linear system.

\begin{lstlisting}[style=cpp]
template<Numerical T>
Vector<T> gmres(
    Sparse<T> &,
    const Vector<T> &)
\end{lstlisting}

The choice of this solver is motivated by the fact that the linear systems consist of unsymmetric, sparse, square matrices. Consequently, \lstinline{gmres} is an excellent solver, even as these matrices grow in size due to an increase in $p$ and $q$ or a decrease in $h$ and $\tau$.

\newpage
\subsection{Error Analysis}

Anticipating the contents of \Cref{section:error_results}, the error analysis consists in the evaluation of of various norms of the error $\Error$ introduced in \cref{subsection:error_estimates}.

The function used to evaluate the various components of the error analysis is the constructor of \lstinline{Error}, defined as follows:
\begin{lstlisting}[style=cpp]
Error(
    const Mesh21 &, 
    const Equation &, 
    const Vector<Real> &, 
    const std::function<Real (Real, Real, Real)> &, 
    const 
        std::function<std::array<Real, 2> (Real, Real, Real)> &)
\end{lstlisting}

This method, similarly to \lstinline{stiffness}, \lstinline{forcing}, and \lstinline{solve}, operates by iterating over all elements of a mesh and performing the necessary quadratures to evaluate the norms in \Cref{section:error_results}. The norm in \cref{eq:inf_error} is computed by maximizing the $\SpaceLp{2}$ error at a fixed time over the entire time interval.

Results are extracted from the test outputs using custom scripts within the library, which are used to generate the data presented in \Cref{chapter:results}.