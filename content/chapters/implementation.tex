\section{Implementation Overview}

This chapter outlines the implementation of the Space-Time Discontinuous Galërkin Method as presented in \cref{chapter:cdr}.

The algorithm has been implemented as part of a comprehensive library, \href{https://github.com/diantonioandrea/ivo}{ivo}\footnote{Named after \href{https://en.wikipedia.org/wiki/Ivo_Babuška}{Ivo Babuška}.}, which was written entirely in \lstinline{C++23} from scratch for this thesis.

The library has been designed to include all the necessary components for the implementation, use, and testing of the algorithm. These components comprise geometric methods and objects in $\RealNumbersTo{2}$ and $\RealNumbersTo{3}$ for mesh generation, dense and sparse matrices for problem formulation, and linear solvers for its solution, as well as additional linear algebra routines and utilities for the definition and manipulation of the principal equation driving the algorithm.

Moreover, the implementation of the algorithm differs slightly from the version introduced and analyzed in \cref{chapter:cdr}.

\newpage
\section{Prismatic Meshes Over Polygonal Domains}

Although it is not necessary to explicitly construct the full space-time mesh for this problem, doing so simplifies the process by providing a straightforward method for accessing individual elements based on their spatial index and time level. 

\subsection{Construction of Polygonal Meshes} \label{subsection:pol_mesh}

\begin{figure}[!ht]
    \begin{subfigure}[b]{0.49\textwidth}
		\centering
        \input{content/tikz/Square_250.tex}
    \end{subfigure}
	\hfill
    \begin{subfigure}[b]{0.49\textwidth}
		\centering
        \input{content/tikz/Square_2000.tex}
    \end{subfigure}
    \caption{Examples of polygonal meshes with $\nSpaceIndices = 250, 2000$.}
\end{figure}

The construction of the polygonal meshes over the problem's polygonal domain is based on the Voronoi mesh construction process and Lloyd's relaxation method.

Let $\Omega \subset \RealNumbersTo{2}$ be a polygonal (and hence bounded) domain, and let $\nSpaceIndices \in \NaturalNumbers$ denote the desired number of elements for $\SpaceMesh$, i.e., the mesh to be constructed. As before, it is customary to let $h$ denote both the mesh index and its characteristic parameter.

The function used to generate polygonal meshes is \lstinline{mesher2}, defined as follows:

\begin{lstlisting}[style=cpp]
namespace ivo {

    std::vector<Polygon21> mesher2(
        const Polygon21 &, 
        const Natural &);

}
\end{lstlisting}

This method first randomly generates $\nSpaceIndices$ points in $\Omega$ and computes their Voronoi cells by iteratively subdividing $\Omega$ using the bisectors corresponding to each point.

The initial diagram, consisting of $\nSpaceIndices$ cells, is then iteratively relaxed using Lloyd's process. At each iteration, a new diagram is generated by considering the centroids of the current cells as the generating points for the Voronoi diagram. This process continues until the residual, defined as the sum of the distances between each point and its previous position, falls below a fixed tolerance.

Finally, postprocessing is performed by collapsing edges that are too short, as such edges may introduce errors in the solution of the problem.

\newpage
\subsubsection{Implementation Details}

The following methods constitute the implementation of \lstinline{mesher2}:

\begin{lstlisting}[style=cpp]
namespace ivo {

	Polygon21 reduce2(
		const Polygon21 &, 
		const Line21 &, 
		const Point21 &);

	std::vector<Point21> random2(
		const Polygon21 &, 
		const Natural &);

	std::vector<Polygon21> voronoi2(
		const Polygon21 &, 
		const std::vector<Point21> &);

	std::vector<Polygon21> voronoi2(
		const Polygon21 &, 
		const Natural &);

	void lloyd2(
		const Polygon21 &, 
		std::vector<Polygon21> &);

	void collapse2(
		const Polygon21 &, 
		std::vector<Polygon21> &);
}
\end{lstlisting}

\lstinline{random2} is responsible for generating randomly placed points within a polygon.

\lstinline{reduce2} partitions a polygon into two parts using a line, retaining the portion in which a specified point lies.

\lstinline{voronoi2} constructs a Voronoi diagram either from a given set of points within a polygon or by first generating these points using \lstinline{random2}. It then iteratively invokes \lstinline{reduce2} to produce the complete diagram.

Finally, \lstinline{lloyd2} relaxes the diagram by iteratively invoking \lstinline{voronoi2} and adjusting the points according to Lloyd's algorithm, while \lstinline{collapse2} identifies edges that should be collapsed, removes them, and repositions any resulting disconnected polygons.

\newpage
Moreover, two additional definitions of \lstinline{mesher2} are provided to respectively load and dump polygonal meshes to a file, thereby avoiding the need to construct a new mesh at each execution:
\begin{lstlisting}[style=cpp]
namespace ivo {

	std::vector<Polygon21> mesher2(
		const std::string &);

	void mesher2(
		const std::string &, 
		const std::vector<Polygon21> &);

}
\end{lstlisting}

\subsubsection{A Code Snippet}

The following snippet illustrates the polygonal mesh construction process.

\lstinputlisting[style=cpp]{content/snippets/mesh2.cpp}

\newpage
\subsection{Construction of Prismatic Meshes}

Let $I \subset \RealNumbers$ be an open interval, and let $\SpaceMesh$ be a polygonal mesh over $\Omega \subset \RealNumbersTo{2}$, constructed as described in \cref{subsection:pol_mesh}. Let $\nTimeIndices \in \NaturalNumbers$ denote the cardinality of the partition $\TimeMesh$.

The function used to generate uniform partitions is \lstinline{mesher1}, defined as follows:
\begin{lstlisting}[style=cpp]
namespace ivo {

    std::vector<Real> mesher1(
        const Real &, 
        const Real &, 
        const Natural &);

}
\end{lstlisting}

This method generates $\nTimeIndices + 1$ uniformly spaced points in $I$, defining its partition $\TimeMesh$.

The function used to generate prismatic meshes, formally $\TimeMesh \times \SpaceMesh$, is the constructor of \lstinline{Mesh21}, defined as follows:
\begin{lstlisting}[style=cpp]
namespace ivo {

    Mesh21(
        const std::vector<Polygon21> &, 
        const std::vector<Real> &, 
        const Natural &p = 1, 
        const Natural &q = 1);

}
\end{lstlisting}

This method, by invoking the constructors of \lstinline{Element21} and \lstinline{Neighbour21}:
\begin{lstlisting}[style=cpp]
namespace ivo {

    Element21(
        const Polygon21 &, 
        const Real &, 
        const Natural &, 
        const Natural &);

    Neighbour21(
        const Integer &, 
        const Integer &, 
        const std::vector<std::array<Integer, 2>> &);

}
\end{lstlisting}
and relying solely on geometric information, constructs the mesh elements and the neighboring structure, where the former serve as wrappers for the element properties, and the latter is a collection of indices mapping each element to its neighbors.

\newpage
\section{Convection-Diffusion-Reaction Problems}

